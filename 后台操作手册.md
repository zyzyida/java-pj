[TOC]

# 前端知识

## web中的k-v存储

【cookie/session/localstorage/sessionstorage】【前端】web中的k-v存储们有什么区别？

https://www.bilibili.com/video/BV1ut411j7R7?from=search&seid=13324000704281297795&spm_id_from=333.337.0.0

|          | cookie              | localstorage             | sessionstorage             | session             |
| -------- | ------------------- | ------------------------ | -------------------------- | ------------------- |
| 结构     | k-v存储、同域名可用 | k-v存储、同域名可用      | k-v存储、同域名可用        | k-v存储、同域名可用 |
| 存储位置 | 客户端              | 客户端                   | 客户端                     | 服务端              |
| 特点     | 随请求头每次提交    | 不随头提交、可长时间保存 | 不随头提交、页面关闭即失效 | 安全                |
| 跨页     | 可跨页、不可跨域    | 可跨页、不可跨域         | 不可跨页、不可跨域         | 可跨页、不可跨域    |

## gin框架



# 后端知识

## Spring

参考资料：https://thinkwon.blog.csdn.net/article/details/104397516

### Spring概述

1. 什么是Spring？核心特性（依赖注入和面向切面编程）
2. Spring框架的设计目标，设计理念和核心是什么？
3. Spring的优缺点是什么？
4. Spring有哪些应用场景
5. Spring由哪些模块组成？
6. Spring 框架中都用到了哪些设计模式？
7. 详细讲解一下核心容器（spring context应用上下文) 模块
8. Spring框架中有哪些不同类型的事件
9. Spring 应用程序有哪些不同组件？
10. 使用 Spring 有哪些方式？

### Spring控制反转

1. 什么是Spring IOC 容器？（就是对组件对象控制权的转移，从程序代码本身转移到了外部容器）

2. 控制反转(IoC,Inversion of Control)有什么作用

3. IOC的优点是什么？

4. Spring IoC 的实现机制

   ```java
     //Spring 中的 IoC 的实现原理就是工厂模式加反射机制。
     interface Fruit {
        public abstract void eat();
      }
     
     class Apple implements Fruit {
         public void eat(){
             System.out.println("Apple");
         }
     }
     
     class Orange implements Fruit {
         public void eat(){
             System.out.println("Orange");
         }
     }
     
     class Factory {
         public static Fruit getInstance(String ClassName) {
             Fruit f=null;
             try {
                 f=(Fruit)Class.forName(ClassName).newInstance();
             } catch (Exception e) {
                 e.printStackTrace();
             }
             return f;
         }
     }
     
     class Client {
         public static void main(String[] a) {
             Fruit f=Factory.getInstance("io.github.dunwu.spring.Apple");
             if(f!=null){
                 f.eat();
             }
         }
     }
     ```

5. Spring 的 IoC支持哪些功能

6. BeanFactory 和 ApplicationContext有什么区别？

7. Spring 如何设计容器的，BeanFactory和ApplicationContext的关系详解

8. ApplicationContext通常的实现是什么？

9. 依赖注入

   1. 什么是Spring的依赖注入？
   2. 依赖注入的基本原则
   3. 依赖注入有什么优势
   4. 有哪些不同类型的依赖注入实现方式？
   5. 构造器依赖注入和 Setter方法注入的区别

### Spring Beans

1. 什么是Spring beans？
2. 一个 Spring Bean 定义包含什么？
3. 如何给Spring 容器提供配置元数据？Spring有几种配置方式
4. Spring配置文件包含了哪些信息
5. Spring基于xml注入bean的几种方式
6. 怎样定义类的作用域？
7. 解释Spring支持的几种bean的作用域
8. Spring框架中的单例bean是线程安全的吗？
9. Spring如何处理线程并发问题？(ThreadLocal)
10. 解释Spring框架中bean的生命周期
11. 哪些是重要的bean生命周期方法？ 你能重载它们吗？
12. 什么是Spring的内部bean？什么是Spring inner beans？
13. 在 Spring中如何注入一个java集合？
14. 什么是bean装配？
15. 什么是bean的自动装配？
16. 解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？
17. 使用@Autowired注解自动装配的过程是怎样的？
18. 自动装配有哪些局限性？
19. 你可以在Spring中注入一个null 和一个空字符串吗？

### Spring注解

1. 什么是基于Java的Spring注解配置? 给一些注解的例子
2. 怎样开启注解装配？
3. @Component, @Controller, @Repository, @Service 有何区别？
4. @Required 注解有什么作用
5. @Autowired 注解有什么作用
6. @Qualifier 注解有什么作用
7. @RequestMapping 注解有什么用？

### Spring数据访问

1. 解释对象/关系映射集成模块
2. 在Spring框架中如何更有效地使用JDBC？
3. 解释JDBC抽象和DAO模块
4. spring DAO 有什么用？
5. spring JDBC API 中存在哪些类？
6. JdbcTemplate是什么
7. 使用Spring通过什么方式访问Hibernate？使用 Spring 访问 Hibernate 的方法有哪些？
8. 如何通过HibernateDaoSupport将Spring和Hibernate结合起来？
9. Spring事务
   1. Spring支持的事务管理类型， spring 事务实现方式有哪些？
   2. Spring事务的实现方式和实现原理
   3. 说一下Spring的事务传播行为
   4. 说一下 spring 的事务隔离？
   5. Spring框架的事务管理有哪些优点？
   6. 你更倾向用那种事务管理类型？

### Spring面向切面编程

1. 什么是AOP
2. Spring AOP and AspectJ AOP 有什么区别？AOP 有哪些实现方式？
3. JDK动态代理和CGLIB动态代理的区别
4. 如何理解 Spring 中的代理？
5. 解释一下Spring AOP里面的几个名词（切面（Aspect）、连接点（Join point）、通知（Advice）、切入点（Pointcut）、引入（Introduction）、目标对象（Target Object）、织入（Weaving））
6. Spring在运行时通知对象
7. Spring只支持方法级别的连接点
8. 在Spring AOP 中，关注点（concern）和横切关注（cross-cutting concern）的区别是什么？
9. Spring通知有哪些类型？
10. 什么是切面 Aspect？（使用 @Aspect 注解的类就是切面.）
11. 解释基于XML Schema方式的切面实现
12. 解释基于注解的切面实现
13. 有几种不同类型的自动代理？



## Spring MVC

参考资料：https://thinkwon.blog.csdn.net/article/details/104397427

### 概述

1. 什么是Spring MVC？简单介绍下你对Spring MVC的理解？（模型-视图-控制器）
2. Spring MVC的优点

### 核心组件

1. Spring MVC的主要组件？
2. 什么是DispatcherServlet
3. 什么是Spring MVC框架的控制器？
4. Spring MVC的控制器是不是[单例模式](https://so.csdn.net/so/search?from=pc_blog_highlight&q=单例模式),如果是,有什么问题,怎么解决？

### 工作原理

1. 请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？
 ![spring-mvc](https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsic3JSxb51bkchaNiadMkibxxyfPF36JmiavzlLAWVA8PRIjYsZ0vwy9DHg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
> 1. 客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。 
> 2. DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）
> 3. DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller
> 4. HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet
> 5. DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。
> 6. DispatcherServlet将模型数据填充到视图中
> 7. DispatcherServlet将结果响应给客户端
2. SpringMVC Restful风格的接口的流程是什么样的呢？
   ![spring-mvc-restful](https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsHssxjGNp9S8WFjHnIU93OSL9JK4rvbIS718UtBz3B1BOZ6xriamz8ug/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)
> 1. 客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet
> 2. DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理
> 3. DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller
> 4. Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理
> 5. HandlerAdapter执行完对Controller的请求，会调用HandlerMethodReturnValueHandler去处理返回值，主要的过程：
>> 1. 调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例
>> 2. 使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中
>> 3. 在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化
> 6. 执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理


### MVC框架

1. MVC是什么？MVC设计模式的好处有哪些

### 常用注解

1. 注解原理是什么
2. Spring MVC常用的注解有哪些？
3. SpingMvc中的控制器的注解一般用哪个,有没有别的注解可以替代？
4. @Controller注解的作用
5. @RequestMapping注解的作用
6. @ResponseBody注解的作用
7. @PathVariable和@RequestParam的区别

### 其他

1. Spring MVC与Struts2区别
2. Spring MVC怎么样设定重定向和转发的？
3. Spring MVC怎么和AJAX相互调用的？
4. 如何解决POST请求中文乱码问题，GET的又如何处理呢？
5. Spring MVC的异常处理？
6. 如果在拦截请求中，我想拦截get方式提交的方法,怎么配置
7. 怎样在方法里面得到Request,或者Session？
8. 如果想在拦截的方法里面得到从前台传入的参数,怎么得到？
9. 如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？
10. Spring MVC中函数的返回值是什么？
11. Spring MVC用什么对象从后台向前台传递数据的？
12. 怎么样把ModelMap里面的数据放入Session里面？
13. Spring MVC里面拦截器是怎么写的
14. 介绍一下 WebApplicationContext

## MyBatis

参考资料：https://thinkwon.blog.csdn.net/article/details/101292950

### 概述

1. MyBatis是什么？
2. ORM（Object Relational Mapping，对象关系映射）是什么？
3. 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？
4. 传统JDBC开发存在的问题
5. JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？
6. Mybatis优缺点
7. MyBatis框架适用场景
8. Hibernate 和 MyBatis 的区别

### 解析和运行原理

1. MyBatis编程步骤是什么样的？
2. 请说说MyBatis的工作原理
3. MyBatis的功能架构是怎样的
4. MyBatis的框架架构设计是怎么样的
5. 为什么需要预编译
6. Mybatis都有哪些Executor执行器？它们之间的区别是什么？
7. Mybatis中如何指定使用哪一种Executor执行器？
8. Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？

### 映射器

1. #{}和${}的区别
2. 模糊查询like语句该怎么写
3. 在mapper中如何传递多个参数
4. Mybatis如何执行批量操作
5. 如何获取生成的主键
6. 当实体类中的属性名和表中的字段名不一样 ，怎么办
7. Mapper 编写有哪几种方式？
8. 什么是MyBatis的接口绑定？有哪些实现方式？
9. 使用MyBatis的mapper接口调用时有哪些要求？
10. 最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗
11. Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？
12. 简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？
13. Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
14. Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？
15. Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？

### 高级查询

1. MyBatis实现一对一，一对多有几种方式，怎么操作的？
2. Mybatis是否可以映射Enum枚举类？

### 动态SQL

1. Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？

### 插件模块

1. Mybatis是如何进行分页的？分页插件的原理是什么？
2. 简述Mybatis的插件运行原理，以及如何编写一个插件。

### 缓存

1. Mybatis的一级、二级缓存



## SSM

SSM框架就是：Spring + Spring MVC + MyBatis

参考资料：https://www.bilibili.com/video/BV1GE411d7KE?p=1 https://www.zhihu.com/question/328810338/answer/720393487

### Spring MVC注解

1. @RequestMapping
   - 参数：value、method、params
2. @Controller
3. 映射 Cookie
4. 使用JavaBean绑定参数
5. JSP页面的转发和重定向
   - 转发：forward
   - 重定向：redirect

### **Spring MVC** 数据绑定

1. 基本数据类型
2. 包装类
3. 数组
4. List
5. Map
6. Json

### **Spring MVC** 模型数据解析

### **Spring MVC** ⾃定义数据转换器

### **Spring MVC REST**

1. GET
2. POST
3. PUT
4. DELETE

### **Spring MVC** 文件上传下载

### **Spring MVC** 数据校验

1. 基于 Validator 接⼝
2. 使用 Annotation JSR - 303 标 准进⾏校验



## Spring Boot

参考资料：https://thinkwon.blog.csdn.net/article/details/104397299

### 概述

1. 什么是 Spring Boot？
2. Spring Boot 有哪些优点？
3. Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？
4. springboot启动流程
   ![spring-boot-start](https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcAT6EsUDOiatUOf1nesAqfsf8eISEyE4LBTJnUIvMg6rrplw76QWZYlcgHMQbFpibAeCSfjCdP8zYg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
5. SpringApplication 这个类主要做了以下四件事情:
> 1. 推断应用的类型是普通的项目还是 Web 项目
> 2. 查找并加载所有可用初始化器 ， 设置到 initializers 属性中
> 3. 找出所有的应用程序监听器，设置到 listeners 属性中
> 4. 推断并设置 main 方法的定义类，找到运行的主类

### 配置

1. 什么是 JavaConfig？
2. Spring Boot 自动配置原理是什么？
3. 如何理解 Spring Boot 配置加载顺序？
4. 什么是 YAML？
5. YAML 配置的优势在哪里?
6. Spring Boot 是否可以使用 XML 配置 ?
7. spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?
8. 什么是 Spring Profiles？
9. 如何在自定义端口上运行 Spring Boot 应用程序？

### 安全

1. 如何实现 Spring Boot 应用程序的安全性？
2. 比较一下 Spring Security 和 Shiro 各自的优缺点 ?
3. Spring Boot 中如何解决跨域问题 ?
4. 什么是 CSRF 攻击？

### 监视器

1. Spring Boot 中的监视器是什么？
2. 如何在 Spring Boot 中禁用 Actuator 端点安全性？
3. 我们如何监视所有 Spring Boot 微服务？

### 整合第三方项目

1. 什么是 WebSockets？
2. 什么是 Spring Data ?
3. 什么是 Spring Batch？
4. 什么是 FreeMarker 模板？
5. 如何集成 Spring Boot 和 ActiveMQ？
6. 什么是 Apache Kafka？
7. 什么是 Swagger？你用 Spring Boot 实现了它吗？
8. 前后端分离，如何维护接口文档 ?

### 其他

1. 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？
2. 您使用了哪些 starter maven 依赖项？
3. Spring Boot 中的 starter 到底是什么 ?
4. spring-boot-starter-parent 有什么用 ?
5. Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?
6. 运行 Spring Boot 有哪几种方式？
7. Spring Boot 需要独立的容器运行吗？
8. 开启 Spring Boot 特性有哪几种方式？
9. 如何使用 Spring Boot 实现异常处理？
10. 如何使用 Spring Boot 实现分页和排序？
11. 微服务中如何实现 session 共享 ?

### 常用注解

https://www.tqwba.com/x_d/jishu/420798.html

https://www.php.cn/faq/417146.html

### 框架分层

SpringBoot框架中大致分成：DAO层、Entity层、Service层、Controller层。链接：https://www.jianshu.com/p/18c4418e9b99

**Entity层**：实体层 数据库在项目中的类

Entity层是实体层，也就是所谓的model，也称为pojo层，是数据库在项目中的类，该文件包含实体类的属性和对应属性的set、get方法；

**DAO层**： 持久层 主要与数据库进行交互

DAO层=mapper层，现在用Mybatis逆向工程生成的mapper层，其实就是dao层。DAO层会调用entity层，DAO中会定义实际使用到的方法，比如增删改查。DAO 层的数据源和数据库连接的参数都是在配置文件中进行配置的，配置文件一般在同层的XML文件夹中。数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作。

**Service层**：业务层 控制业务

Service层主要负责业务模块的逻辑应用设计。先设计放接口的类，再创建实现的类，然后在配置文件中进行配置其实现的关联。service层调用dao层接口，接收dao层返回的数据，完成项目的基本功能设计。

封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。

**Controller层**：控制层   控制业务逻辑

Controller层负责具体的业务模块流程的控制，controller层负责前后端交互，接受前端请求，调用service层，接收service层返回的数据，最后返回具体的页面和数据到客户端。
 Controller层像是一个服务员，他把客人（前端）点的菜（数据、请求的类型等）进行汇总什么口味、咸淡、量的多少，交给厨师长（Service层），厨师长则告诉沾板厨师（Dao 1）、汤料房（Dao 2）、配菜厨师（Dao 3）等（统称Dao层）我需要什么样的半成品，副厨们（Dao层）就负责完成厨师长（Service）交代的任务。

总结，业务逻辑：

```php
Controller-->service接口-->serviceImpl-->dao接口-->daoImpl-->mapper-->db
```

在具体的项目中，其流程为：Controller层调用Service层的方法，Service层调用Dao层中的方法，其中调用的参数是使用Entity层进行传递的。总的来说这样每层做什么的分类只是为了使业务逻辑更加清晰，写代码更加方便，所以有时候也需要根据具体情况来，但是大体的都是这样处理的，因为它其实就是提供一种规则，让你把相同类型的代码放在一起，这样就形成了层次，从而达到分层解耦、复用、便于测试和维护的目的。

### 工程实战

1. entity：新建与数据相关的实体类
2. repository：新建与数据库相连的接口
3. vo：新建与前端交互的数据类（后端到前端）
4. service：新建服务前端的业务层类
5. controller：控制层（与前端url进行交互）
6. 其他
   1. config：处理跨域问题
   2. dto：把业务数据转成数据库对应的格式（前端到后端）
   3. enums：枚举类
   4. exception：异常处理类
   5. form：前端到后端的数据验证
   6. util：工具类



## Spring cloud

参考资料：https://thinkwon.blog.csdn.net/article/details/104397367

### 概述

1. 为什么需要学习Spring Cloud
2. 什么是Spring Cloud
3. 设计目标与优缺点
4. Spring Cloud发展前景
5. 整体架构

### 主要项目

1. Spring Cloud Config
2. Spring Cloud Netflix
3. Spring Cloud Bus
4. Spring Cloud Consul
5. Spring Cloud Security
6. Spring Cloud Sleuth
7. Spring Cloud Stream
8. Spring Cloud Task
9. Spring Cloud Zookeeper
10. Spring Cloud Gateway
11. Spring Cloud OpenFeign

### 其他

1. SpringBoot和SpringCloud的区别？
2. 使用 Spring Boot 开发分布式微服务时，我们面临的问题
3. 服务注册和发现是什么意思？Spring Cloud 如何实现？
4. Spring Cloud 和dubbo区别?
5. 负载平衡的意义什么？
6. 什么是 Hystrix？它如何实现容错？
7. 什么是 Hystrix 断路器？我们需要它吗？
8. 什么是 Netflix Feign？它的优点是什么？
9. 什么是 Spring Cloud Bus？我们需要它吗？
10. Spring Cloud断路器的作用
11. 什么是Spring Cloud Config?
12. 什么是Spring Cloud Gateway?

### 创建父工程

Spring Cloud Alibaba 的环境在父工程中创建，微服务的各个组件作为子工程，继承父工程的环境。

Spring Boot ---》Spring Cloud ---》Spring Cloud Alibaba

pom.xml 中添加。

```xml
<dependencyManagement>
    <dependencies>
        <!-- Spring Cloud Hoxton -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>Hoxton.SR3</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <!-- Spring Cloud Alibaba -->
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
            <version>2.2.1.RELEASE</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```



## Nacos

### Nacos 服务注册

解压，启动服务。

Nacos 搭建成功，接下来注册服务。

在父工程路径下创建子工程，让子工程继承父工程的环境依赖，pom.xml 中添加 nacos 发现组件。

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

application.yml 中配置

```yaml
spring:
  cloud:
    nacos:
      discovery:
        # 指定nacos server地址
        server-addr: localhost:8848
  application:
    name: my-nacos
```



### Nacos 服务发现与调用

pom.xml 添加 discovery，完成服务发现。

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

通过 discoveryClient 发现注册到 nacos 中的 provider 服务。

```java
@RestController
public class ConsumerController {

    @Autowired
    private DiscoveryClient discoveryClient;

    @GetMapping("/instances")
    public List<ServiceInstance> instances(){
        List<ServiceInstance> provider = discoveryClient.getInstances("provider");
        return provider;
    }

}
```

```java
@Configuration
public class ConsumerConfig {

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

}
```

```java
@RestController
public class ConsumerController {

    @Autowired
    private DiscoveryClient discoveryClient;
    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/index")
    public String index(){
        List<ServiceInstance> provider = discoveryClient.getInstances("provider");
        int index = ThreadLocalRandom.current().nextInt(provider.size());
        String url = provider.get(index).getUri()+"/index";
        return "consumer随机远程调用provier："+this.restTemplate.getForObject(url, String.class);
    }

}
```



## Ribbon 负载均衡

Ribbon不是Spring Cloud Alibaba的组件，是Netflix提供的，默认使用轮询算法（依次调用）。

<img src="/Users/yidazyz/Desktop/截屏2021-12-13 下午6.42.25.png" style="zoom:50%;" />     

```java
@Configuration
public class ConsumerConfig {

    @Bean
    @LoadBalanced
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

}
```

```java
@RestController
public class ConsumerController {

    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/index")
    public String index(){
        return "consumer远程调用provier："+this.restTemplate.getForObject("http://provider/index", String.class);
    }

}
```

> 随机

```yaml
server:
  port: 8180
provider:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
```

> Nacos 权重

```java
@Slf4j
public class NacosWeightedRule extends AbstractLoadBalancerRule {

    @Autowired
    private NacosDiscoveryProperties nacosDiscoveryProperties;

    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) {
        //读取配置文件
    }

    @Override
    public Server choose(Object o) {
        ILoadBalancer loadBalancer = this.getLoadBalancer();
        BaseLoadBalancer baseLoadBalancer = (BaseLoadBalancer) loadBalancer;
        //获取要请求的微服务名称
        String name = baseLoadBalancer.getName();
        //获取服务发现的相关API
        NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();
        try {
            Instance instance = namingService.selectOneHealthyInstance(name);
            log.info("选择的实例是port={},instance={}",instance.getPort(),instance);
            return new NacosServer(instance);
        } catch (NacosException e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

```yaml
server:
  port: 8180
provider:
  ribbon:
    NFLoadBalancerRuleClassName: com.southwind.configuration.NacosWeightedRule
```



## Sentinel 服务限流降级

雪崩效应

解决方案

1、设置线程超时

2、设置限流

3、熔断器：Sentinel、Hystrix

1、启动sentinel服务：

```shell
java -Dserver.port=8089 -Dcsp.sentinel.dashboard.server=localhost:8089 -jar sentinel-dashboard-1.7.2.jar
```

<img src="/Users/yidazyz/Desktop/截屏2021-12-13 下午6.44.41.png" style="zoom:60%;" />

2、pom.xml 引入依赖

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

3、application 配置

```yaml
management:
  endpoints:
    web:
      exposure:
        include: '*'
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080
```

3、下载 Sentinel 控制台，解压，启动。

### 流控规则

> 直接限流

> 关联限流

> 链路限流

1、pom.xml 添加依赖

```xml
<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-core</artifactId>
    <version>1.7.1</version>
</dependency>

<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-web-servlet</artifactId>
    <version>1.7.1</version>
</dependency>
```

2、application.yml

```yml
spring:
	cloud:
        sentinel:
          filter:
            enabled: false
```

3、写配置类

```java
package com.southwind.configuration;

import com.alibaba.csp.sentinel.adapter.servlet.CommonFilter;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class FilterConfiguration {

    @Bean
    public FilterRegistrationBean registrationBean(){
        FilterRegistrationBean registrationBean = new FilterRegistrationBean();
        registrationBean.setFilter(new CommonFilter());
        registrationBean.addUrlPatterns("/*");
        registrationBean.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY,"false");
        registrationBean.setName("sentinelFilter");
        return registrationBean;
    }
}
```

4、Service

```java
@Service
public class HelloService {

    @SentinelResource("test")
    public void test(){
        System.out.println("test");
    }
}
```

5、Controller

```java
@GetMapping("/test1")
public String test1(){
    this.helloService.test();
    return "test1";
}

@GetMapping("/test2")
public String test2(){
    this.helloService.test();
    return "test2";
}
```



### 流控效果

> 快速失败

直接抛出异常

> Warm UP

给系统一个预热的时间，预热时间段内单机阈值较低，预热时间过后单机阈值增加，预热时间内当前的单机阈值是设置的阈值的三分之一，预热时间过后单机阈值恢复设置的值。

> 排队等待

当请求调用失败之后，不会立即抛出异常，等待下一次调用，时间范围是超时时间，在时间范围内如果能请求成功则不抛出异常，如果请求则抛出异常。



### 降级规则

> RT

单个请求的响应时间超过阈值，则进入准降级状态，接下来 1 S 内连续 5 个请求响应时间均超过阈值，就进行降级，持续时间为时间窗口的值。

> 异常比例

每秒异常数量占通过量的比例大于阈值，就进行降级处理，持续时间为时间窗口的值。

> 异常数

1 分钟内的异常数超过阈值就进行降级处理，时间窗口的值要大于 60S，否则刚结束熔断又进入下一次熔断了。



### 热点规则

热点规则是流控规则的更细粒度操作，可以具体到对某个热点参数的限流，设置限流之后，如果带着限流参数的请求量超过阈值，则进行限流，时间为统计窗口时长。

必须要添加 @SentinelResource，即对资源进行流控。 

```java
@GetMapping("/hot")
@SentinelResource("hot")
public String hot(
        @RequestParam(value = "num1",required = false) Integer num1,
        @RequestParam(value = "num2",required = false) Integer num2){
    return num1+"-"+num2;
}
```



### 授权规则

给指定的资源设置流控应用（追加参数），可以对流控应用进行访问权限的设置，具体就是添加白名单和黑名单。

如何给请求指定流控应用，通过实现 RequestOriginParser 接口来完成，代码如下所示。

```java
package com.southwind.configuration;

import com.alibaba.csp.sentinel.adapter.servlet.callback.RequestOriginParser;
import org.springframework.util.StringUtils;

import javax.servlet.http.HttpServletRequest;

public class RequestOriginParserDefinition implements RequestOriginParser {
    @Override
    public String parseOrigin(HttpServletRequest httpServletRequest) {
        String name = httpServletRequest.getParameter("name");
        if(StringUtils.isEmpty(name)){
            throw new RuntimeException("name is null");
        }
        return name;
    }
}
```

要让 RequestOriginParserDefinition 生效，需要在配置类中进行配置。

```java
package com.southwind.configuration;

import com.alibaba.csp.sentinel.adapter.servlet.callback.WebCallbackManager;
import org.springframework.context.annotation.Configuration;

import javax.annotation.PostConstruct;

@Configuration
public class SentinelConfiguration {

    @PostConstruct
    public void init(){
        WebCallbackManager.setRequestOriginParser(new RequestOriginParserDefinition());
    }
}
```



### 自定义规则异常返回

创建异常处理类

```java
package com.southwind.handler;

import com.alibaba.csp.sentinel.adapter.servlet.callback.UrlBlockHandler;
import com.alibaba.csp.sentinel.slots.block.BlockException;
import com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;
import com.alibaba.csp.sentinel.slots.block.flow.FlowException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class ExceptionHandler implements UrlBlockHandler {
    @Override
    public void blocked(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlockException e) throws IOException {
        httpServletResponse.setContentType("text/html;charset=utf-8");
        String msg = null;
        if(e instanceof FlowException){
            msg = "限流";
        }else if(e instanceof DegradeException){
            msg = "降级";
        }
        httpServletResponse.getWriter().write(msg);
    }
}
```

进行配置。

```java
@Configuration
public class SentinelConfiguration {

    @PostConstruct
    public void init(){
        WebCallbackManager.setUrlBlockHandler(new ExceptionHandler());
    }
}
```



## RocketMQ

### 安装 RocketMQ 

1、传入 Linux 服务器

2、解压缩

```
unzip rocketmq-all-4.7.1-bin-release.zip
```

此处有坑，需要需改一下shell之中的JAVA_HOME路径，修改为JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_211.jdk/Contents/Home，参考资料为：https://blog.csdn.net/jack1liu/article/details/104997361?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.nonecase

3、启动 NameServer

```
cd bin
nohup ./mqnamesrv &
```

4、检查是否启动成功

```
netstat -an | grep 9876
```

5、启动 Broker

启动之前需要编辑配置文件，修改 JVM 内存设置，默认给的内存 4 GB，超过我们的 JVM 了。

```shell
cd bin
vim runserver.sh
```

```
vim runbroker.sh
```

启动 Broker

```
nohup ./mqbroker -n localhost:9876 &
```

可以查看日志

```
tail -f ~/logs/rocketmqlogs/broker.log
```

启动成功

6、测试 RocketMQ

消息发送

```shell
export NAMESRV_ADDR=localhost:9876
./tools.sh org.apache.rocketmq.example.quickstart.Producer
```

消息接收

```
cd bin
export NAMESRV_ADDR=localhost:9876
./tools.sh org.apache.rocketmq.example.quickstart.Consumer
```

7、关闭 RocketMQ

```
cd bin
./mqshutdown broker
./mqshutdown namesrv
```



### 安装 RocketMQ 控制台

1、解压缩，修改配置，打包

```
mvn clean package -Dmaven.test.skip=true
```

![image-20200612190454926](C:\Users\ningn\AppData\Roaming\Typora\typora-user-images\image-20200612190454926.png)

2、进入 target 启动 jar

```
java -jar rocketmq-console-ng-1.0.0.jar 
```

打开浏览器访问 localhost:9877，如果报错

这是因为我们的 RocketMQ 安装在 Linux 中，控制台在 windows，Linux 需要开放端口才能访问，开放 10909 和 9876 端口

```shell
firewall-cmd --zone=public --add-port=10909/tcp --permanent
firewall-cmd --zone=public --add-port=9876/tcp --permanent
systemctl restart firewalld.service
firewall-cmd --reload
```

重新启动控制台项目



### Java 实现消息发送

1、pom.xml 中引入依赖

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-spring-boot-starter</artifactId>
    <version>2.1.0</version>
</dependency>
```

2、生产消息

```java
package com.southwind;

import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;

public class Test {
    public static void main(String[] args) throws Exception {
        //创建消息生产者
        DefaultMQProducer producer = new DefaultMQProducer("myproducer-group");
        //设置NameServer
        producer.setNamesrvAddr("192.168.248.129:9876");
        //启动生产者
        producer.start();
        //构建消息对象
        Message message = new Message("myTopic","myTag",("Test MQ").getBytes());
        //发送消息
        SendResult result = producer.send(message, 1000);
        System.out.println(result);
        //关闭生产者
        producer.shutdown();
    }
}
```

3、直接运行，如果报错 sendDefaultImpl call timeout，可以开放 10911 端口

```shell
firewall-cmd --zone=public --add-port=10911/tcp --permanent
systemctl restart firewalld.service
firewall-cmd --reload
```

打开 RocketMQ 控制台，可查看消息。

### Java 实现消息消费

```java
package com.southwind.service;

import lombok.extern.slf4j.Slf4j;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.common.message.MessageExt;

import java.util.List;

@Slf4j
public class ConsumerTest {
    public static void main(String[] args) throws MQClientException {
        //创建消息消费者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("myconsumer-group");
        //设置NameServer
        consumer.setNamesrvAddr("192.168.248.129:9876");
        //指定订阅的主题和标签
        consumer.subscribe("myTopic","*");
        //回调函数
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(List<MessageExt> list, ConsumeConcurrentlyContext consumeConcurrentlyContext) {
                log.info("Message=>{}",list);
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        //启动消费者
        consumer.start();
    }
}
```



### Spring Boot 整合 RocketMQ

> provider

1、pom.xml

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-spring-boot-starter</artifactId>
    <version>2.1.0</version>
</dependency>
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.7.0</version>
</dependency>
```

2、application.yml

```yaml
rocketmq:
  name-server: 192.168.248.129:9876
  producer:
    group: myprovider
```

3、Order

```java
package com.southwind.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Order {
    private Integer id;
    private String buyerName;
    private String buyerTel;
    private String address;
    private Date createDate;
}
```

4、Controller

```java
@Autowired
private RocketMQTemplate rocketMQTemplate;

@GetMapping("/create")
public Order create(){
    Order order = new Order(
        1,
        "张三",
        "123123",
        "软件园",
        new Date()
    );
    this.rocketMQTemplate.convertAndSend("myTopic",order);
    return order;
}
```

> consumer

1、pom.xml

```xml
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-spring-boot-starter</artifactId>
    <version>2.1.0</version>
</dependency>
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.7.0</version>
</dependency>
```

2、application.yml

```yaml
rocketmq:
  name-server: 192.168.248.129:9876
```

3、Service

```java
@Slf4j
@Service
@RocketMQMessageListener(consumerGroup = "myConsumer",topic = "myTopic")
public class SmsService implements RocketMQListener<Order> {
    @Override
    public void onMessage(Order order) {
        log.info("新订单{},发短信",order);
    }
}
```



## 服务网关

即 传达室。

Zuul第一代网关

Spring Cloud Gateway 是基于 Netty，跟 Servlet 不兼容，所以你的工程中不能出现 Servlet 的组件 。

1、pom.xml

注意，一定不能出现 spring web 的依赖，因为 Gateway 与 Servlet 不兼容。

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

2、application.yml

```yaml
server:
  port: 8010
spring:
  application:
    name: gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
      routes: 
        - id: provider_route   
          uri: http://localhost:8081 
          predicates: 
            - Path=/provider/** 
          filters:
            - StripPrefix=1
```

上面这种做法其实没有用到 nacos ，现在我们让 gateway 直接去 nacos 中发现服务，配置更加简单了。

1、pom.xml 引入 nacos

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

2、application.yml

```yaml
server:
  port: 8010
spring:
  application:
    name: gateway
  cloud:
      gateway:
        discovery:
          locator:
            enabled: true
```



### Gateway 限流

基于路由限流

1、pom.xml

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

<dependency>
    <groupId>com.alibaba.csp</groupId>
    <artifactId>sentinel-spring-cloud-gateway-adapter</artifactId>
</dependency>
```

2、配置类

```java
package com.southwind.configuration;

import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayRuleManager;
import com.alibaba.csp.sentinel.adapter.gateway.sc.SentinelGatewayFilter;
import com.alibaba.csp.sentinel.adapter.gateway.sc.callback.BlockRequestHandler;
import com.alibaba.csp.sentinel.adapter.gateway.sc.callback.GatewayCallbackManager;
import com.alibaba.csp.sentinel.adapter.gateway.sc.exception.SentinelGatewayBlockExceptionHandler;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.codec.ServerCodecConfigurer;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.web.reactive.result.view.ViewResolver;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import javax.annotation.PostConstruct;
import java.util.*;

@Configuration
public class GatewayConfiguration {
    private final List<ViewResolver> viewResolvers;
    private final ServerCodecConfigurer serverCodecConfigurer;


    public GatewayConfiguration(ObjectProvider<List<ViewResolver>> viewResolversProvider,
                                ServerCodecConfigurer serverCodecConfigurer) {
        this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);
        this.serverCodecConfigurer = serverCodecConfigurer;
    }

    //配置限流的异常处理
    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() {
        return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);
    }

    //配置初始化的限流参数
    @PostConstruct
    public void initGatewayRules(){
        Set<GatewayFlowRule> rules = new HashSet<>();
        rules.add(
                new GatewayFlowRule("provider_route")
                .setCount(1)
                .setIntervalSec(1)
        );
        GatewayRuleManager.loadRules(rules);
    }

    //初始化限流过滤器
    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public GlobalFilter sentinelGatewayFilter() {
        return new SentinelGatewayFilter();
    }

    //自定义限流异常页面
    @PostConstruct
    public void initBlockHandlers(){
        BlockRequestHandler blockRequestHandler = new BlockRequestHandler() {
            @Override
            public Mono<ServerResponse> handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) {
                Map map = new HashMap();
                map.put("code",0);
                map.put("msg","被限流了");
                return ServerResponse.status(HttpStatus.OK)
                        .contentType(MediaType.APPLICATION_JSON)
                        .body(BodyInserters.fromObject(map));
            }
        };
        GatewayCallbackManager.setBlockHandler(blockRequestHandler);
    }
}
```

3、application.yml

```yaml
server:
  port: 8010
spring:
  application:
    name: gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
      routes:
        - id: provider_route
          uri: http://localhost:8081
          predicates:
            - Path=/provider/**
          filters:
            - StripPrefix=1
```

基于 API 分组限流

1、修改配置类，添加基于 API 分组限流的方法，修改初始化的限流参数

```java
package com.southwind.configuration;

import com.alibaba.csp.sentinel.adapter.gateway.common.SentinelGatewayConstants;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiDefinition;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiPathPredicateItem;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.ApiPredicateItem;
import com.alibaba.csp.sentinel.adapter.gateway.common.api.GatewayApiDefinitionManager;
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayFlowRule;
import com.alibaba.csp.sentinel.adapter.gateway.common.rule.GatewayRuleManager;
import com.alibaba.csp.sentinel.adapter.gateway.sc.SentinelGatewayFilter;
import com.alibaba.csp.sentinel.adapter.gateway.sc.callback.BlockRequestHandler;
import com.alibaba.csp.sentinel.adapter.gateway.sc.callback.GatewayCallbackManager;
import com.alibaba.csp.sentinel.adapter.gateway.sc.exception.SentinelGatewayBlockExceptionHandler;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.codec.ServerCodecConfigurer;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.web.reactive.result.view.ViewResolver;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import javax.annotation.PostConstruct;
import java.util.*;

@Configuration
public class GatewayConfiguration {

    private final List<ViewResolver> viewResolvers;
    private final ServerCodecConfigurer serverCodecConfigurer;


    public GatewayConfiguration(ObjectProvider<List<ViewResolver>> viewResolversProvider,
                                ServerCodecConfigurer serverCodecConfigurer) {
        this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);
        this.serverCodecConfigurer = serverCodecConfigurer;
    }

    //配置限流的异常处理
    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() {
        return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);
    }

    //配置初始化的限流参数
    @PostConstruct
    public void initGatewayRules(){
        Set<GatewayFlowRule> rules = new HashSet<>();
        rules.add(new GatewayFlowRule("provider_api1").setCount(1).setIntervalSec(1));
        rules.add(new GatewayFlowRule("provider_api2").setCount(1).setIntervalSec(1));
        GatewayRuleManager.loadRules(rules);
    }

    //初始化限流过滤器
    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public GlobalFilter sentinelGatewayFilter() {
        return new SentinelGatewayFilter();
    }

    //自定义限流异常页面
    @PostConstruct
    public void initBlockHandlers(){
        BlockRequestHandler blockRequestHandler = new BlockRequestHandler() {
            @Override
            public Mono<ServerResponse> handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) {
                Map map = new HashMap();
                map.put("code",0);
                map.put("msg","被限流了");
                return ServerResponse.status(HttpStatus.OK)
                        .contentType(MediaType.APPLICATION_JSON)
                        .body(BodyInserters.fromObject(map));
            }
        };
        GatewayCallbackManager.setBlockHandler(blockRequestHandler);
    }

    //自定义API分组
    @PostConstruct
    private void initCustomizedApis(){
        Set<ApiDefinition> definitions = new HashSet<>();
        ApiDefinition api1 = new ApiDefinition("provider_api1")
                .setPredicateItems(new HashSet<ApiPredicateItem>(){{
                    add(new ApiPathPredicateItem().setPattern("/provider/api1/**")
                            .setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX));
                }});
        ApiDefinition api2 = new ApiDefinition("provider_api2")
                .setPredicateItems(new HashSet<ApiPredicateItem>(){{
                    add(new ApiPathPredicateItem().setPattern("/provider/api2/demo1"));
                }});
        definitions.add(api1);
        definitions.add(api2);
        GatewayApiDefinitionManager.loadApiDefinitions(definitions);
    }
}
```

2、Controller 添加方法

```java
@GetMapping("/api1/demo1")
public String demo1(){
    return "demo";
}

@GetMapping("/api1/demo2")
public String demo2(){
    return "demo";
}

@GetMapping("/api2/demo1")
public String demo3(){
    return "demo";
}

@GetMapping("/api2/demo2")
public String demo4(){
    return "demo";
}
```

也可以基于 Nacos 服务发现组件进行限流

```yaml
server:
  port: 8010
spring:
  application:
    name: gateway
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
```

API 分组代码修改，改为 discovery 中的服务名。

```java
ApiDefinition api2 = new ApiDefinition("provider_api2")
        .setPredicateItems(new HashSet<ApiPredicateItem>(){{
            add(new ApiPathPredicateItem().setPattern("/p1/api2/demo1"));
        }});
```



## 分布式事务

### 模拟分布式事务异常

1、创建两个工程 order、pay，pom.xml

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
```

2、建两个数据库 order、pay，两个微服务分别访问。

3、分别写两个服务的 application.yml

```yaml
server:
  port: 8010
spring:
  application:
    name: order
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/order
```

```yaml
server:
  port: 8020
spring:
  application:
    name: pay
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
    url: jdbc:mysql://localhost:3306/pay
```

4、分别写两个 Service

```java
package com.southwind.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

@Service
public class OrderService {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void save(){
        this.jdbcTemplate.update("insert into orders(username) values ('张三')");
    }
}
```

```java
package com.southwind.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

@Service
public class PayService {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    public void save(){
        this.jdbcTemplate.update("insert into pay(username) values ('张三')");
    }
}
```

5、控制器 Order 通过 RestTemplate 调用 Pay 的服务

```java
package com.southwind.controller;

import com.southwind.service.OrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class OrderController {

    @Autowired
    private OrderService orderService;
    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/save")
    public String save(){
        //订单
        this.orderService.save();
        int i = 10/0;
        //支付
        this.restTemplate.getForObject("http://localhost:8020/save",String.class);
        return "success";
    }
}
```

```java
package com.southwind.controller;

import com.southwind.service.PayService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class PayController {
    @Autowired
    private PayService payService;

    @GetMapping("/save")
    public String save(){
        this.payService.save();
        return "success";
    }
}
```

6、启动类

```java
package com.southwind;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
public class OrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

```java
package com.southwind;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PayApplication {

    public static void main(String[] args) {
        SpringApplication.run(PayApplication.class, args);
    }

}
```

分布式异常模拟结束，Order 存储完成之后，出现异常，会导致 Pay 无法存储，但是 Order 数据库不会进行回滚。



### Seata 解决

1、下载

2、解压，修改两个文件

regisry.conf

```conf
registry {
  type = "nacos"
  nacos {
    serverAddr = "localhost"
    namespace = "public"
    cluster = "default"
  }
}

config {
  type = "nacos"
  nacos {
    serverAddr = "localhost"
    namespace = "public"
    cluster = "default"
  }
}
```

nacos-config.txt![截屏2021-12-24 下午4.55.10](/Users/yidazyz/Library/Application Support/typora-user-images/截屏2021-12-24 下午4.55.10.png)

3、启动 Nacos，运行 nacos-config.sh 将 Seata 配置导入 Nacos

进入 conf，右键 Git Bash Here

```
cd conf
sh nacos-config.sh 127.0.0.1
```

执行成功，刷新 Nacos，配置加入

nacos-config.txt 配置已生效

4、启动 Seata Server，  **JDK 8 以上环境无法启动**

```
cd bin
sh seata-server.sh -p 8090 -m file
```

启动成功，Nacos 注册成功。

Seata 服务环境搭建完毕，接下来去应用中添加。

1、初始化数据库，在两个数据库中添加事务日志记录表，SQL Seata 已经提供。

2、直接在两个数据库运行脚本。

```sql
CREATE TABLE `undo_log` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `branch_id` bigint(20) NOT NULL,
  `xid` varchar(100) NOT NULL,
  `context` varchar(128) NOT NULL,
  `rollback_info` longblob NOT NULL,
  `log_status` int(11) NOT NULL,
  `log_created` datetime NOT NULL,
  `log_modified` datetime NOT NULL,
  `ext` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

3、两个工程的 pom.xml 添加 Seata 组件和 Nacos Config 组件。

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
    <version>2.1.1.RELEASE</version>
</dependency>

<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>
```

4、给 JDBCTemplate 添加代理数据源

```java
package com.southwind;

import io.seata.rm.datasource.DataSourceProxy;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.web.client.RestTemplate;

import javax.sql.DataSource;

@SpringBootApplication
public class OrderApplication {

    public static void main(String[] args) {
        SpringApplication.run(OrderApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource){
        return new JdbcTemplate(new DataSourceProxy(dataSource));
    }
}
```

```java
package com.southwind;

import io.seata.rm.datasource.DataSourceProxy;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;

@SpringBootApplication
public class PayApplication {

    public static void main(String[] args) {
        SpringApplication.run(PayApplication.class, args);
    }

    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource){
        return new JdbcTemplate(new DataSourceProxy(dataSource));
    }

}
```

5、将 registry.conf 复制到两个工程的 resources 下。

6、给两个工程添加 bootstrap.yml 读取 Nacos 配置。

```yaml
spring:
  application:
    name: order
  cloud:
    nacos:
      config:
        server-addr: localhost:8848
        namespace: public
        group: SEATA_GROUP
    alibaba:
      seata:
        tx-service-group: ${spring.application.name}
```

```yaml
spring:
  application:
    name: pay
  cloud:
    nacos:
      config:
        server-addr: localhost:8848
        namespace: public
        group: SEATA_GROUP
    alibaba:
      seata:
        tx-service-group: ${spring.application.name}
```

tx-service-group 需要和 Nacos 配置中的名称一致。

7、在 Order 调用 Pay 处添加注解 @GlobalTransactional

```java
package com.southwind.controller;

import com.southwind.service.OrderService;
import io.seata.spring.annotation.GlobalTransactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

@RestController
public class OrderController {

    @Autowired
    private OrderService orderService;
    @Autowired
    private RestTemplate restTemplate;

    @GetMapping("/save")
    @GlobalTransactional
    public String save(){
        //订单
        this.orderService.save();
        int i = 10/0;
        //支付
        this.restTemplate.getForObject("http://localhost:8020/save",String.class);
        return "success";
    }
}
```



## Go

### 开发实战

1. model：新建与数据相关的实体类
2. repository：新建与数据库相连的接口
3. vo：新建与前端交互的数据类（后端到前端）
4. repository：新建服务前端的业务层类
5. service：新建服务前端的业务层类
6. controller：控制层（与前端url进行交互）
7. 其他
   1. config：处理跨域问题
   2. dto：把业务数据转成数据库对应的格式（前端到后端）
   3. enums：枚举类
   4. exception：异常处理类
   5. form：前端到后端的数据验证
   6. util：工具类



## 设计模式



# 日常学习

参考：https://javaguide.cn/home.html#%E5%BF%85%E7%9C%8B%E4%B8%93%E6%A0%8F

## 计算机基础

## Java

## 数据库

## 开发工具

## 系统设计

## 分布式

### 理论#算法#协议



### 网关



### RPC

Remote Procedure Call，即远程过程调用，通过RPC可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。

一言蔽之：**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**

RPC原理：

1. 客户端（服务消费端）
2. 客户端Stub（桩）：代理类
3. 网络传输
4. 服务端Stub（桩）
5. 服务端（服务提供端）

![37345851](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/37345851.jpg)

![32527396](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-12-6/32527396.jpg)调用过程：

1. 服务消费端（client）以本地调用的方式调用远程服务；
2. 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：`RpcRequest`；
3. 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；
4. 服务端 Stub（桩）收到消息将消息反序列化为Java对象: `RpcRequest`；
5. 服务端 Stub（桩）根据`RpcRequest`中的类、方法、方法参数等信息调用本地的方法；
6. 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：`RpcResponse`（序列化）发送至消费方；
7. 客户端 Stub（client stub）接收到消息并将消息反序列化为Java对象:`RpcResponse` ，这样也就得到了最终结果。

Dubbo解决的问题：

1. 负载均衡
2. 服务调用链路生成
3. 服务访问压力以及时常统计、资源调度和治理

Dubbo架构

![dubbo-relation](https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/%E6%BA%90%E7%A0%81/dubbo/dubbo-relation.jpg)

上述节点简单介绍以及他们之间的关系：

- **Container：** 服务运行容器，负责加载、运行服务提供者。必须。
- **Provider：** 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。
- **Consumer：** 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。
- **Registry：** 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。
- **Monitor：** 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。





### 分布式ID

**产生的背景**

单机 MySQL 已经没办法支撑业务时，需要进行分库分表（推荐 Sharding-JDBC）。

在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。**我们如何为不同的数据节点生成全局唯一主键呢？**

**分布式ID的特性**

1. 全局唯一
2. 高性能
3. 高可用
4. 方便易用
5. 安全
6. 有序递增
7. 有具体的业务含义
8. 独立部署

**分布式ID常见解决方案**

1. 数据库
   1. 数据库自增主键
   2. 数据库号段模式
   3. NoSQL：Redis(Redis Cluster、Codis)、MongoDB ObjectId
2. 算法
   1. UUID：Universally Unique Identifier（通用唯一标识符）
   2. Snowflake(雪花算法)
3. 开源框架
   1. UidGenerator
   2. Leaf
   3. Tinyid



### 分布式事务



### 分布式协调



## 高性能



## 高可用





